<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../hints_style.css">
	<title>set_error_handler</title>
	<script>	
		var exampleText = "mixed set_error_handler ( callback $error_handler [, int $error_types = E_ALL | E_STRICT ] )";
	</script>
</head>

<body class="html set_error_handler">
	<nav>
		<a class="back" onclick="history.back()">▼</a>
		<a class="forward" onclick="history.forward()">▼</a>
	</nav>

	<header>
		<h1>set_error_handler</h1>
	</header>

	<section id="example" onclick="Coda.copyExample(exampleText);" >
		
		<h2>Example</h2>
		<code class="codeblock" id="examplecode" title="Click to insert code sample.">
			
			<pre class="source-code php"><span class="php"> <span class="identifier">mixed</span> <span class="identifier">set_error_handler</span> ( <span class="identifier">callback</span> <span class="tag">$<span class="identifier">error_handler</span></span> [, <span class="keyword type">int</span> <span class="tag">$<span class="identifier">error_types</span></span> = <span class="identifier">E_ALL</span> | <span class="identifier">E_STRICT</span> ] ) </span></pre>			
		</code>
	</section>

	<section id="description" >

		<h2>Description</h2>
		
		<p>Sets a user function (error_handler) to handle errors in a script. This function can be used for defining your own way of handling errors during runtime, for example in applications in which you need to do cleanup of data/files when a critical error happens, or when you need to trigger an error under certain conditions (using trigger_error()). It is important to remember that the standard PHP error handler is completely bypassed for the error types specified by error_types unless the callback function returns FALSE. error_reporting() settings will have no effect and your error handler will be called regardless - however you are still able to read the current value of error_reporting and act appropriately. Of particular note is that this value will be 0 if the statement that caused the error was prepended by the @ error-control operator. Also note that it is your responsibility to die() if necessary. If the error-handler function returns, script execution will continue with the next statement after the one that caused an error. The following error types cannot be handled with a user defined function: E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING, and most of E_STRICT raised in the file where set_error_handler() is called. If errors occur before the script is executed (e.g. on file uploads) the custom error handler cannot be called since it is not registered at that time.</p>		
	</section>
			
	<section id="returns">
		
		<h2>Return Values</h2>
					
		<p>Returns a string containing the previously defined error handler (if any). If the built-in error handler is used NULL is returned. NULL is also returned in case of an error such as an invalid callback. If the previous error handler was a class method, this function will return an indexed array with the class and the method name.</p>	</section>

	

</body>
</html>
