/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */


// Global constants

var emptyNoteText = dashcode.getLocalizedString("Type your note here");
var emptyTagsText = dashcode.getLocalizedString("Click to add tags, comma-separated");
var growboxInset;                               // Global variable used for resizing
var defaultWidgetHeight = 236;                  // Default widget height
var minWidgetHeight = defaultWidgetHeight;      // Minimum widget height
var maxWidgetHeight = 600;                      // Maximum widget height

var colorDisabled = "#a67b29";                  // Color for the note text
var colorDimmed = "#16381e";                    // Color for green text, e.g. for tags
var colorText = "#000";                         // Color for the note text

var saveTimer = null;                           // Reference for the save timer

// The available fonts
var availableFonts = new Array();
availableFonts[0] = "Comic Sans MS";
availableFonts[1] = "Courier";
availableFonts[2] = "Marker Felt";
availableFonts[3] = "Times";
availableFonts[4] = "Verdana";

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
    var i = 0;
    var fontMenu = document.getElementById("fontmenu");

    dashcode.setupParts();
    
    // Set up the fonts menu
    var fontMenuArray = new Array();
    for(i=0; i<availableFonts.length; i++)
    {
        var keyValuePair = new Array();
        keyValuePair[0] = availableFonts[i];
        keyValuePair[1] = availableFonts[i];
        fontMenuArray.push(keyValuePair);
    }
    fontMenu.object.setOptions(fontMenuArray);

    // Load font preference
    var userFont = widget.preferenceForKey("font");
    if(userFont)
    {
        for(i=0; i<availableFonts.length; i++)
        {
            if(availableFonts[i] == userFont)
            {
                fontMenu.object.setSelectedIndex(i);
                changeFontTo(userFont);
           }
        }
    }
    else
    {
        fontMenu.object.setSelectedIndex(2);
    }
    
    // Load default tags
    var defaultTags = widget.preferenceForKey("tags");
    if(defaultTags)
    {
        document.getElementById("tags").value = defaultTags;
        document.getElementById("defaulttags").value = defaultTags;
    }
    else
    {
        onBlurTags(null);  // Sets the default text
    }
   
    resetWidgetHeight();  // Load saved window height
    focusNote(null);  // Set default text
    loadNote();  // Load note from preferences
    onChangeNote(null);  // Disable the Save button using the predefined method
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    saveNote();
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    setWidgetHeight(defaultWidgetHeight);

    if (window.widget) {
        widget.prepareForTransition("ToBack");
    }

    front.style.display = "none";
    back.style.display = "block";

    if (window.widget) {
        setTimeout('widget.performTransition();', 0);
    }
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");
    
    // Save preferences if needed
    savePreferences();

    resetWidgetHeight();

    if (window.widget)
    {
        widget.prepareForTransition("ToFront");
    }

    front.style.display="block";
    back.style.display="none";

    if (window.widget)
    {
        setTimeout('widget.performTransition();', 0);
    }
    
    onBlurTags();
    onBlurNote();
}

if (window.widget) {
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}


//
//
//  Here the actual custom code begins
//
//

// Focus the note field
function focusNote(event)
{
    document.getElementById("note").focus();
}

// Remove sample text when the user focuses the note field
function onFocusNote(event)
{
    if(document.getElementById("note").value == emptyNoteText)
    {
        document.getElementById("note").value = "";
        onChangeNote(null);
    }
}

// Re-add the sample text top the note field if necessary
function onBlurNote(event)
{
    if(document.getElementById("note").value == "")
    {
        document.getElementById("note").value = emptyNoteText;
        onChangeNote(null);
    }
    
    saveNote();
}

// Enable or disable the Save button, reset save timer (when the timer's up, the note is saved)
function onChangeNote(event)
{
    if(document.getElementById("note").value == "" || document.getElementById("note").value == emptyNoteText)
        document.getElementById("savebutton").object.setEnabled(false);
    else
        document.getElementById("savebutton").object.setEnabled(true);
    
    if(document.getElementById("note").value == emptyNoteText)
        document.getElementById("note").style.color = colorDisabled;
    else
        document.getElementById("note").style.color = colorText;
}

// Save the note to preferences
function saveNote()
{
    var savedNote = null;
    if(document.getElementById("note").value != emptyNoteText)
        savedNote = document.getElementById("note").value;
    var savedTags = document.getElementById("tags").value;

    widget.setPreferenceForKey(savedNote, "savednote");
    widget.setPreferenceForKey(document.getElementById("tags").value, "savedtags");
    
    return document.getElementById("note").value;
}

// Load the note from preferences
function loadNote()
{
    var savedNote = widget.preferenceForKey("savednote");
    var savedTags = widget.preferenceForKey("savedtags");
    if (savedNote != undefined)
        document.getElementById("note").value = savedNote;
    if (savedTags != undefined)
    document.getElementById("tags").value = savedTags;
    
    return document.getElementById("note").value;
}

// Save the note to DEVONthink using the x-devonthink: handler
function saveNoteToDEVONthink(event)
{
    // Get the note text etc.
    var noteText = document.getElementById("note").value;
    var tagsText = document.getElementById("tags").value;
    
    if(noteText != "" && noteText != emptyNoteText)
    {
        var today = new Date();
        var humanReadableDate = today.toLocaleString() ;
    
        // Use the first line of the note text as the title
        if(noteText.indexOf("\n") != -1)
        {
            noteTitle = noteText.substring(0, noteText.indexOf("\n"));
        }
        else
        {
            noteTitle = noteText;
        }
        
        // Execute the x-devonthink: URL
        var newNoteURL = 'x-devonthink://createText'
            + '?title=' + encodeURIComponent(noteTitle)
            + '&text=' + encodeURIComponent(noteText)
            + '&location=localhost';
        if (tagsText != "" && tagsText != emptyTagsText)
        {
            newNoteURL += '&tags=' + encodeURIComponent(tagsText);
        }

        widget.openURL(newNoteURL);
        
        widget.setPreferenceForKey("", "savednote");
        widget.setPreferenceForKey("", "savedtags");
        document.getElementById("note").value = "";
        document.getElementById("tags").value = "";
        document.getElementById("note").blur();
        document.getElementById("tags").blur();
        onBlurNote(null);
    }
}

// Opens the DEVONtechnologies home page in the default browser
function openHomepage(event)
{
    widget.openURL("http://www.devon-technologies.com/products/devonthink");
}

function startResize(event)
{
    // Add listeners
    document.addEventListener("mousemove", moveResize, true);
    document.addEventListener("mouseup", endResize, true);
 
    // Calculate the inset of the resize gadget
    growboxInset = {x:(window.innerWidth - event.x), y:(window.innerHeight - event.y)};
 
    // Clean up
    event.stopPropagation();
    event.preventDefault();
}

function moveResize(event)
{
    // var x = event.x + growboxInset.x;
    var y = event.y + growboxInset.y
 
    // Set the new window height
    setWidgetHeight(y);

    // Clean up
    event.stopPropagation();
    event.preventDefault();
}


function setWidgetHeight(y)
{
    if(y >= minWidgetHeight && y <= maxWidgetHeight)
    {
        // Adjust the position of the resize element
        document.getElementById("resize").style.top = (y-12);
        
        // Resize the window
        window.resizeTo(window.innerWidth,y);

        // Manually adjust the height of the note area
        var newNoteHeight = (y-148) + "px";
        document.getElementById("note").style.height = newNoteHeight;
    }
}

function resetWidgetHeight()
{
    var userHeight = widget.preferenceForKey("height");
    if(userHeight)
    {
        setWidgetHeight(userHeight);
    }
}

function endResize(event)
{
    // Remove listeners
    document.removeEventListener("mousemove", moveResize, true);
    document.removeEventListener("mouseup", endResize, true);
    
    // Save preference
    widget.setPreferenceForKey(window.innerHeight, "height");

    // Clean up
    event.stopPropagation();
    event.preventDefault();
}

function changeFontTo(theFont)
{
    document.getElementById("note").style.fontFamily = theFont;
}

function changeTagsTo(theTags)
{
    document.getElementById("tags").value = theTags;
}

function savePreferences()
{
    // Get values from back side form
    var fontMenu = document.getElementById("fontmenu");
    var selectedFont = fontMenu.object.getValue();
    var theDefaultTags = document.getElementById("defaulttags").value;

    // Write preferences
    widget.setPreferenceForKey(selectedFont, "font");
    if(theDefaultTags != "") widget.setPreferenceForKey(theDefaultTags, "tags");
    
    // Apply changes
    changeFontTo(selectedFont);
    changeTagsTo(theDefaultTags);
}

// Remove sample text when the user focuses the tags field and adjust color
function onFocusTags(event)
{
    if(document.getElementById("tags").value == emptyTagsText)
    {
        document.getElementById("tags").value = "";
        document.getElementById("tags").style.color = colorDimmed;
    }
}

// Re-add the sample text top the tags field if necessary and adjust color
function onBlurTags(event)
{
    if(document.getElementById("tags").value == "")
    {
        document.getElementById("tags").value = emptyTagsText;
        document.getElementById("tags").style.color = colorDisabled;
    }
}
